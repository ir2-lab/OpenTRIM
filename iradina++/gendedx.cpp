/*
    Adapted from Corteo by F. Schiettekatte
    http://www.lps.umontreal.ca/~schiette/index.php?n=Recherche.Corteo
*/

#include "dedx.h"
#include "elements.h"

#include <cmath>
#include <cfloat>

#include <iostream>
#include <fstream>
#include <iomanip>

#ifdef WIN32
const char endline[] = "\n";
#else
// in Linux or mac, where SRModule is called using Wine, we must feed an input file containing return+linefeed
const char endline[] = "\r\n";
#endif

using namespace std;

string srim_command;
string out_folder;

int parse(int argc, char* argv[]);
int doit();

int main(int argc, char* argv[])
{
    if (parse(argc,argv)<0) return -1;
    return doit();
}

int parse(int argc, char* argv[])
{
    const char* usage = "Usage: gendedx srim_cmd out_folder";
    if (argc!=3) {
        cout << usage << endl;
        return -1;
    }
    srim_command = string(argv[1]);
    out_folder = string(argv[2]);
    return 0;
}

int run_srim(int Z1, int Z2, vector<float>& data)
{
    {
        // write SRModule input file
        ofstream os("SR.IN");
        os << endline << endline
           << "SR_OUTPUT.txt"
           << endline << endline
           << Z1 << ' ' << elements::mostAbundantIsotope(Z1)
           << endline << endline
           << " 0 1 0"
           << endline << endline
           << "1"
           << endline << endline
           << Z2 << " \"X\" 1 1"
           << endline << endline
           << " 7"
           << endline << endline
           << " 0 0 " << endline;

        for(const float erg : dedx_index()) os << erg/1000 << endline;

        os << " 0 ";
    }

    system(srim_command.c_str());

    {
        ifstream is("SR_OUTPUT.txt");
        char buff[4096];
        is.getline(buff,4096);
        is.getline(buff,4096);
        is.getline(buff,4096);
        is.getline(buff,4096);

        int i=0;
        while(is.good() && i<data.size())
        {
            double d, dedxval;
            is >> d >> data[i];
            is.getline(buff,4096);
            i++;
        }

        if (!is.good()) {
            cerr << "Failed to read sr.out" << endl;
            return -1;
        }
    }

    return 0;
}

int print_cpp_matrix(ofstream& Z1cpp, int Z1, int Z2, const vector<float>& data)
{
    Z1cpp << "static const float "
          << elements::name(Z1)
          << "_on_"
          << elements::name(Z2)
          << "[] = {";
    const int val_per_line = 10;
    for(int i=0; i<data.size()-1; ++i) {
        if (i % val_per_line == 0) Z1cpp << endl << "    ";
        Z1cpp << data[i] << ", ";
    }
    Z1cpp << data.back() << "};" << endl << endl;
    return 0;
}

int print_cpp_element_matrix(ofstream& Z1cpp, int Z1, int Z2max)
{
    Z1cpp << "const float* dedx"
          << elements::name(Z1)
          << "[] = { nullptr,";
    const int val_per_line = 5;
    for(int Z2=1; Z2<=Z2max; Z2++) {
        if (((Z2-1) % val_per_line) == 0) Z1cpp << endl << "    ";
        Z1cpp << elements::name(Z1)
              << "_on_"
              << elements::name(Z2);
        if (Z2<Z2max) Z1cpp << ", ";
        else Z1cpp << "};" << endl << endl;
    }
    return 0;
}

// Generate dE/dx files for all elements in all elements (part of setup)
// - for each Z from 1 to 92
//     - create a file Z.asp
//     - for each element from H to U
//        - write a SRIModule input file to have the dE/dx at DIMD energies
//        - run SRIModule
//        - read the output
//        - write the result in .asp file, appended by the Z of the element as a control data
int doit()
{
    const char* preample = "// file generated by gendedx - do not edit\n\n";

    vector<float> data(dedx_index::dim);

    int Zmax = elements::max_atomic_num;
    cout << "Generating dedx data:" << endl;
    for(int Z1=1; Z1<=Zmax; Z1++) {
        cout << elements::name(Z1) << ' ';
        cout.flush();
        string fname(out_folder);
        fname += "/";
        fname += elements::name(Z1);
        fname += ".cpp";
        ofstream Z1cpp(fname);
        // Z1cpp << fixed << setprecision(4);
        Z1cpp << preample;
        for(int Z2=1; Z2<=Zmax; Z2++) {
            if (Z2 % 10 == 0) {
                cout << '.'; cout.flush();
            }
            if (run_srim(Z1,Z2,data)<0) return -1;
            print_cpp_matrix(Z1cpp,Z1,Z2,data);
        }
        print_cpp_element_matrix(Z1cpp, Z1, Zmax);
        cout << endl;
    }

    { // generate master file dedx_data.cpp
        string fname(out_folder);
        fname += "/dedx_data.cpp";
        ofstream cpp(fname);
        cpp << preample;

        for(int Z1=1; Z1<=Zmax; Z1++) {
            cpp << "extern const float* dedx"
                << elements::name(Z1) << "[];" << endl;
        }
        cpp << endl;

        cpp << "const float** dedx_data[] = { nullptr, ";
        const int val_per_line = 5;
        for(int Z1=1; Z1<=Zmax; Z1++) {
            if (((Z1-1) % val_per_line) == 0) cpp << endl << "    ";
            cpp << "dedx" << elements::name(Z1);
            if (Z1<Zmax) cpp << ", ";
            else cpp << "};" << endl << endl;
        }
     }

    return 0;
}



