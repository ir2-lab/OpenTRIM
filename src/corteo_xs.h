#ifndef CORTEO_XS_H
#define CORTEO_XS_H

#include "xs.h"
#include "corteo.h"

#include <Eigen/Dense>

/**
 * @brief The xs_corteo_index struct provides N-bit indexing for tabulated screened Coulomb cross-sections
 *
 * Quantities are tabulated as a function of reduced energy and impact parameter
 *
 * This structure defines 2 corteo indexes:
 *   - e_index for the reduced energy with [21-(-19)]*2^N + 1 points (rows) from \f$ 2^{-19} \f$ to \f$ 2^{21} \f$
 *   - s_index for the reduced impact parameter with [6-(-26)]*2^N + 1 points (columns) from \f$ 2^{-26} \f$ to \f$ 2^{6} \f$
 *
 * For typical values of N we have the following dimensions:
 *   - 4-bit: N=4, rows=641, columns=513, 32-bit float table memory = 1.25 MB
 *   - 6-bit: N=6, rows=2561, columns=2049, 32-bit float table memory = 20 MB
 *
 * @ingroup XS
 */
template<int Nb>
struct xs_corteo_index {
    /// Corteo N-bit index for the reduced energy
    typedef corteo_index<float, int, Nb, -19, 21> e_index;
    /// Corteo N-bit index for the reduced impact parameter
    typedef corteo_index<float, int, Nb, -26,  6> s_index;
    /// number of rows (energy values)
    constexpr static const int rows = e_index::size;
    /// number of columns (impact parameter values)
    constexpr static const int cols = s_index::size;
    /**
     * @brief Calculate the table index for given energy and impact parameter
     *
     * Return the index to the memory location where the value that corresponds
     * to given energy and impact parameter is stored.
     *
     * Tables are stored in C-style row-major order.
     *
     * @param e the reduced energy
     * @param s the reduced impact parameter
     * @return the table index
     */
    static int table_index(const float& e, const float& s) {
        return e_index(e)*cols + s_index(s);
    }
};

const float* xs_zbl_data();
const float* xs_krc_data();
const float* xs_lj_data();
const float* xs_moliere_data();
// Returns a pointer to the pre-computed table
template<Screening ScreeningType>
struct corteo4bitdata {
    static const float* data() { return nullptr; }
};
template<>
struct corteo4bitdata<Screening::ZBL> {
    static const float* data() { return xs_zbl_data(); }
};
template<>
struct corteo4bitdata<Screening::LenzJensen> {
    static const float* data() { return xs_lj_data(); }
};
template<>
struct corteo4bitdata<Screening::KrC> {
    static const float* data() { return xs_krc_data(); }
};
template<>
struct corteo4bitdata<Screening::Moliere> {
    static const float* data() { return xs_moliere_data(); }
};



/**
 * @brief 4-bit corteo-tabulated screened potential scattering integral
 *
 * A 2-dimensional pre-caclulated table of \f$ \sin^2\theta/2 \f$ as a function of reduced energy
 * and reduced impact parameter, where \f$ \theta \f$ is
 * the center-of-mass scattering angle for the ZBL screened potential.
 *
 * The table is generated by \ref xs_quad, which
 * employs Gaussâ€“Chebyshev quadrature to compute the scattering integral.
 *
 * The tabulated values are calculated at log-spaced energy
 * and impact factor values as documented in \ref xs_corteo_index.
 *
 *
 * @ingroup XS
 */
template<Screening ScreeningType>
struct xs_corteo4bit : public screening_function< ScreeningType >,
                       public corteo4bitdata< ScreeningType >
{
    using corteo4bitdata< ScreeningType >::data;

    /// The 2D corteo index type
    typedef xs_corteo_index<4> corteo_idx_t;
    /// Number of table rows (energy values)
    constexpr const static int rows = corteo_idx_t::rows;
    /// Number of table columns (impact parameter values)
    constexpr const static int cols = corteo_idx_t::cols;

    /// Returns the tabulated value of \f$ \sin^2\theta(\epsilon,s)/2 \f$
    static double sin2Thetaby2(const double& e, const double& s)
    {
        const float* p = data();
        int i = corteo_idx_t::table_index(e,s);
        return p[i];
    }
    /// Returns the tabulated value of \f$ \sin^2\theta(i,j)/2 \f$
    static float sin2Thetaby2(int ie, int is)
    {
        const float* p = data();
        return p[ie*cols + is];
    }

};

// bilinear interp
struct xs_corteo_lin_interp {

    constexpr const static int stride = xs_corteo_index<4>::cols;
    typedef xs_corteo_index<4>::e_index e_index;
    typedef xs_corteo_index<4>::s_index s_index;
    typedef Eigen::Vector4i idx_vec_t;
    typedef Eigen::Vector4f coef_vec_t;

    static void get_arrays(float e, float s, idx_vec_t& i, coef_vec_t& c) {
        e_index ie(e);
        s_index is(s);
        int k = ie * stride + is;
        i[0] = k++; i[1] = k;
        k += stride-1;
        i[2] = k++; i[3] = k;
        float t = *ie++, u = *is++;
        t = (e - t)/(*ie - t);
        u = (s - u)/(*is - u);
        c = {(1-t)*(1-u), (1-t)*u, t*(1-u), t*u};
    }
};

struct xs_corteo_log_interp {

    constexpr const static int stride = xs_corteo_index<4>::cols;
    typedef xs_corteo_index<4>::e_index e_index;
    typedef xs_corteo_index<4>::s_index s_index;
    typedef Eigen::Vector4i idx_vec_t;
    typedef Eigen::Vector4f coef_vec_t;

    xs_corteo_log_interp()
    {
        for(e_index i; i<i.end(); i++)
            log_e_[i] = std::log(*i);
        for(s_index i; i<i.end(); i++)
            log_s_[i] = std::log(*i);
    }

    void get_arrays(float e, float s, idx_vec_t& i,
                    coef_vec_t& c_lin, coef_vec_t& c_log) const
    {
        e_index ie(e);
        s_index is(s);
        int k = ie * stride + is;
        i[0] = k++; i[1] = k;
        k += stride-1;
        i[2] = k++; i[3] = k;

        float t = *ie, u = *is;
        float t1 = log_e_[ie++], u1 = log_s_[is++];
        t = (e - t)/(*ie - t);
        u = (s - u)/(*is - u);
        c_lin = {(1-t)*(1-u), (1-t)*u, t*(1-u), t*u};

        t1 = (std::log(e) - t1)/(log_e_[ie] - t1);
        u1 = (std::log(s) - u1)/(log_s_[is] - u1);
        c_log = {(1-t1)*(1-u1), (1-t1)*u1, t1*(1-u1), t1*u1};
    }

    void get_arrays(float e, float s, idx_vec_t& i,
                    coef_vec_t& c_log) const
    {
        e_index ie(e);
        s_index is(s);
        int k = ie * stride + is;
        i[0] = k++; i[1] = k;
        k += stride-1;
        i[2] = k++; i[3] = k;

        float t1 = log_e_[ie++], u1 = log_s_[is++];
        t1 = (std::log(e) - t1)/(log_e_[ie] - t1);
        u1 = (std::log(s) - u1)/(log_s_[is] - u1);
        c_log = {(1-t1)*(1-u1), (1-t1)*u1, t1*(1-u1), t1*u1};
    }

private:
    Eigen::Matrix<float, e_index::size, 1> log_e_;
    Eigen::Matrix<float, s_index::size, 1> log_s_;
};



// implementation of XSlab for corteo-tabulated center-of-mass XS
template<Screening ScreeningType>
class xs_corteo_impl_ : public abstract_xs_lab
{
    typedef xs_quad<ScreeningType> _XSQ;
    typedef xs_corteo4bit<ScreeningType> _XS;
    typedef typename _XS::corteo_idx_t corteo_idx_t;
    typedef typename corteo_idx_t::e_index e_index;
    typedef typename corteo_idx_t::s_index s_index;
    constexpr const static int stride = corteo_idx_t::cols;
    constexpr const static int array_size = corteo_idx_t::rows * corteo_idx_t::cols;
    typedef Eigen::VectorXf xs_array_t;
    xs_array_t sinTable, cosTable;
    xs_array_t log_xs_;
    xs_corteo_log_interp interp;
public:
    xs_corteo_impl_() :
        sinTable(array_size),
        cosTable(array_size),
        log_xs_(array_size)
    {}
    xs_corteo_impl_(const xs_corteo_impl_& x) :
        abstract_xs_lab(x),
        sinTable(x.sinTable),
        cosTable(x.cosTable),
        log_xs_(x.log_xs_)
        //,
        //log_xs_(x.log_xs_), log_e_(x.log_e_), log_s_(x.log_s_)
    {}
    virtual void init(float Z1, float M1, float Z2, float M2) override
    {
        abstract_xs_lab::init_impl_<_XS>(Z1,M1,Z2,M2);
        /* compute scattering angle components */
        double costhetaLab, sinthetaLab;
        double mr = mass_ratio_;
        for (e_index ie; ie!=ie.end(); ie++)
            for (s_index is; is!=is.end(); is++)
            {
                double s2 = _XS::sin2Thetaby2(ie,is);
                double costheta = 1.-2.*s2;

                if(costheta==-1.0 && mr==1.0) {
                    costhetaLab = 0.0;  /* peculiar case of head-on collision of identical masses */
                    sinthetaLab = 1.0;
                } else {
                    costhetaLab = (costheta+mr)/sqrt(1.+2.*mr*costheta+mr*mr);
                    sinthetaLab = sqrt(1.-costhetaLab*costhetaLab);
                }

                int k = ie*stride + is;
                cosTable[k] = costhetaLab;
                sinTable[k] = sinthetaLab;
                log_xs_[k] = std::log(s2);

                /* IRADINA, C. Borschel 2011: */
                /* In some rare cases, when cos=1, then sin becomes "Not a Number".
                 * To prevent this, I will set the sine to 0 in those cases. */
                if( std::isnan(sinTable[k]) ) {
                    cosTable[k]=0.f;
                    sinTable[k]=1.f;
                }
            }
    }
    virtual void scatter(float e, float s,
                         float &recoil_erg, float &sintheta, float &costheta) const override
    {
        const float* p = _XS::data();
        recoil_erg = e*gamma_;
        e *= red_E_conv_;
        s /= screening_length_;

        Eigen::Vector4i i;
        Eigen::Vector4f coeff, log_coeff;
        // xs_corteo_lin_interp::get_arrays(e,s,i,coeff);
        interp.get_arrays(e,s,i,coeff,log_coeff);

        sintheta = coeff.dot(sinTable(i));
        costheta = coeff.dot(cosTable(i));
        recoil_erg *= exp(log_coeff.dot(log_xs_(i)));

    }
    virtual float impactPar(float E, float T) const override
    {
        double thetaCM = 1.0*T/E/gamma_;
        if (thetaCM > 1.0) return std::numeric_limits<float>::quiet_NaN();
        if (thetaCM == 1.0) return 0.f;
        thetaCM = 2.*std::asin(std::sqrt(thetaCM));
        return _XSQ::findS(E*red_E_conv_,thetaCM)*screening_length_;

    }
    virtual float crossSection(float E, float T) const override
    {
        double thetaCM = 1.0*T/E/gamma_;
        if (thetaCM > 1.0) return std::numeric_limits<float>::quiet_NaN();
        thetaCM = 2.*std::asin(std::sqrt(thetaCM));
        return _XSQ::crossSection(E*red_E_conv_,thetaCM)*4*sig0_/E/gamma_;
    }
    virtual float stoppingPower(float E) const override
    {
        return _XSQ::stoppingPower(E*red_E_conv_)*sig0_*gamma_/red_E_conv_;
    }
    virtual float stoppingPower(float E, float T1) const override
    {
        double theta_max = 1.0*T1/E/gamma_;
        if (theta_max >= 1.0) return stoppingPower(E);
        theta_max = 2.*std::asin(std::sqrt(theta_max));
        return _XSQ::stoppingPower(E*red_E_conv_,theta_max)*sig0_*gamma_/red_E_conv_;
    }
};


/**
 * @brief xs_lab implementation with ZBL potential and 4-bit corteo tabulated center-of-mass scattering angle
 *
 * @ingroup XS
 */
typedef xs_corteo_impl_< Screening::ZBL > xs_lab_zbl;
typedef xs_corteo_impl_< Screening::LenzJensen > xs_lab_lj;
typedef xs_corteo_impl_< Screening::KrC > xs_lab_krc;
typedef xs_corteo_impl_< Screening::Moliere > xs_lab_moliere;


#endif // CORTEO_XS_H
