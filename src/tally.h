#ifndef TALLY_H
#define TALLY_H

#include "arrays.h"
#include "ion.h"
#include "target.h"

/**
 * \defgroup Tallies Tallies and event streams 
 *
 * \brief The results of the Monte-Carlo simulation
 *
 * @ingroup MC
 *
 */

/**
 * @brief The types of Monte-Carlo events
 * 
 * @ingroup Tallies
 * 
 */
enum class Event : uint32_t {
    NewSourceIon = 1 << 0, /**< A new ion track is started. */
    NewRecoil    = 1 << 1, /**< A new recoil track is started. */
    Scattering   = 1 << 2, /**< An ion scattering occured. */
    IonExit      = 1 << 3, /**< An ion exits the simulation volume. */
    IonStop      = 1 << 4, /**< An ion stops inside the simulation volume. */
    BoundaryCrossing = 1 << 5, /**< An ion crosses an internal boundary. */
    Replacement  = 1 << 6, /**< A replacement event occurs. */
    Vacancy      = 1 << 7, /**< A vacancy is created. */
    CascadeComplete = 1 << 8, /**< A PKA cascade is complete. */
    NewFlightPath  = 1 << 9,
    NEvent         = 1 << 10
};

/**
 * @brief The tally class obtains and organizes Monte-Carlo scores in tables 
 * 
 * The \ref tally_t enum enumerates the standard score tables.
 * 
 * All tables are 2-dimentional, \f$ [N_{at} \times N_c]\f$, where
 * \f$N_{at}\f$ is the number of atoms in the simulation (including the projectile ion)
 * and \f$N_c\f$ the number of cells, except the very first table (i=0)
 * which stores the total scores for histories, PKAs, etc. 
 * 
 * Tally scores are stored in double real number format.
 * 
 * The element \f$A_k(i,j)\f$ of the \f$k\f$-th table stores the score
 * of the given quantity generated by an atom of id\f$=i\f$ in the
 * \f$j\f$-th cell. E.g., a vacancy of atom with id=2 generated in the cell
 * with index 10 will score +1 in \f$A_1(2,10)\f$. 
 * 
 * For some tables the projectile (\f$i=0\f$)
 * does not have a meaningfull contribution; e.g., vacancies are
 * only from one of the target atoms, not the projectile.
 * Thus, in this case the 0-th row of the respective table is all zeros.
 * Note that the id of an atom in the simulation
 * is not defined by the atomic species only.
 * E.g., we may have Fe projectiles (i=0) impinging
 * on a target containig Fe2O3 (Fe with id=1) and bulk Fe (Fe with id=3).
 * 
 * The tables are divided in groups:
 * - Energy deposition (Ionization, phonons, etc)
 * - Defects (Vacancies, replacements, etc.)
 * - Damage Parameters (Damage energy, NRT vacancies, etc.)
 * - Ion statistics (Flight path, collisions)
 * 
 * The grouping is preserved when the tables are saved in the \ref out_file "output archive".
 * 
 * In memory, the tally scores add up the contributions from all ion histories.
 * When saved into the \ref out_file "HDF5 output file" all scores are divided by
 * the number of histories, thus, they are normalized "per ion".
 * 
 * @ingroup Tallies
 * @see out_file
 * 
 */
class tally {

public:

    /// @brief The type of tally table
    enum tally_t {
        cT = 0, /**< Table of total counts (histories, PKAs, Vacancies, etc)  */
        cV = 1, /**< Vacancies  */
        cI = 2, /**< Interstitials or Implanted ions  */
        cR = 3, /**< Replacements  */
        cP = 4, /**< PKAs  */
        cL = 5, /**< Lost ions (they exit the simulation)  */
        eIoniz = 6, /**< Ionization energy  */
        ePhonon = 7, /**< Phonon energy  */
        ePKA = 8, /**< PKA recoil energy  */
        eLost = 9, /**< Energy of lost ions  */
        dpTdam = 10, /**< Damage energy  */
        dpTdam_LSS = 11, /**< Damage energy predicted by LSS theory */
        dpVnrt = 12, /**< NRT Vacancies based on Tdam */
        dpVnrt_LSS = 13, /**< NRT Vacancies based on Tdam_LSS */
        isFlightPath = 14, /**< Ion flight path */
        isCollision = 15, /**< Ion collisions */
        tEnd = 16
    };

    /// Number of standard tally tables
    static const int std_tallies = tEnd;
    /// Return the short name of the i-th tally table
    static const char* arrayName(int i);
    /// Return a description for the i-th tally table
    static const char* arrayDescription(int i);
    /// Return the group name for the i-th tally table
    static const char* arrayGroup(int i);

    /*
     * Totals: 1 (N-ions,V-vacancies,I-interst/implant,R-replace,P-pka, L-lost,D-displ) 7 x 1
     *
     * Cell counters: 5 (V,I,R,P,L) atoms x cells
     *
     * Energy : 3 (Ioniz, Phonon, PKA, Lost) atoms x cells
     *
     * Damage : 4 (Tdam, Tdam_LSS, Vnrt, Vnrt_LSS) atom x cells
     *
     */

protected:

    std::array< ArrayNDd, std_tallies > A;

    enum counter_t {
        H = 0,
        V = 1,
        I = 2,
        R = 3,
        P = 4,
        L = 5,
        D = 6
    };

    

    uint32_t EventMask_ { static_cast<uint32_t>(Event::NEvent) - 1 };

public:

    /// Return the total ion histories
    const double& Nions() const { return A[cT](H); }
    /// Return the total # of PKAs
    const double& Npkas() const { return A[cT](P); }
    /// Return the total # of displacements
    const double& Ndisp() const { return A[cT](D); }
    /// Return the total # of replacements
    const double& Nrepl() const { return A[cT](R); }
    /// Return the total # of interstitials or implantations
    const double& Nimpl() const { return A[cT](I); }
    /// Return the total # of vacancies
    const double& Nvac()  const { return A[cT](V); }
    /// Return the total # of lost ions (the ones that exited the simulation volume)
    const double& Nlost() const { return A[cT](L); }

    const ArrayNDd& vacancies() const { return A[cV]; }
    const ArrayNDd& implantations() const { return A[cI]; }
    const ArrayNDd& replacements() const { return A[cR]; }
    const ArrayNDd& pkas() const { return A[cP]; }
    const ArrayNDd& lost() const { return A[cL]; }

    const ArrayNDd& ionization() const { return A[eIoniz]; }
    const ArrayNDd& phonons() const { return A[ePhonon]; }
    const ArrayNDd& lostE() const { return A[eLost]; }
    const ArrayNDd& pkaE() const { return A[ePKA]; }

    const ArrayNDd& Tdam() const { return A[dpTdam]; }
    const ArrayNDd& Tdam_LSS() const { return A[dpTdam_LSS]; }
    const ArrayNDd& Vnrt() const { return A[dpVnrt]; }
    const ArrayNDd& Vnrt_LSS() const { return A[dpVnrt_LSS]; }

    /// Return the i-th tally score table
    const ArrayNDd& at(int i) const { return A[i]; }

    /// @brief Initialize tally buffers for given # of atoms and cells 
    void init(int natoms, int ncells) {
        A[0] = ArrayNDd(7);
        for(int i=1; i<std_tallies; i++)
            A[i] = ArrayNDd(natoms,ncells);
    }

    /// @brief Zero-out all tally scores
    void clear() {
        for(int i=0; i<std_tallies; i++)
            A[i].clear();
    }

    /// @brief Add the scores from another tally
    /// @param t another tally object
    /// @return this object
    tally& operator+=(const tally& t) {
        for(int i=0; i<A.size(); i++)
            A[i] += t.A[i];
        return *this;
    }

    /// @brief Add the squared scores from another tally, i.e., x[i] += x'[i]*x'[i]
    /// @param t another tally object
    void addSquared(const tally& t) {
        for(int i=0; i<A.size(); i++)
            A[i].addSquared(t.A[i]);
    }

    /// @brief Copy contents from another tally
    /// @param t another tally object
    void copy(const tally& t) {
        for(int i=0; i<A.size(); i++)
            A[i] = t.A[i].copy();
    }

    /// @brief Score an event
    /// @param ev the event type
    /// @param i the ion causing the event
    /// @param pv pointer to additional data, if available
    inline void operator()(Event ev, const ion& i, const void* pv = 0)
    {
        int iid = i.myAtom()->id(), cid=i.cellid(), pid=i.prev_cellid();
        const float* p;
        const atom* a;
        switch (ev) {
        case Event::BoundaryCrossing:
            A[isCollision](iid,pid) += i.ncoll();
            A[isFlightPath](iid,pid) += i.path();
            A[ePhonon](iid,pid) += i.phonon();
            A[eIoniz](iid,pid) += i.ioniz();
            break;
        case Event::Replacement:
            // add a replacement
            A[cT](R)++;
            A[cR](iid,cid)++; // this atom, current cell
            // Remove a Vac
            A[cT](V)--;
            // for the replaced atom (id passed in pointer pv), in current cell
            a = reinterpret_cast<const atom*>(pv);
            A[cV](a->id(),cid)--;
            // if this was a recoil, add a V at the starting cell
            if (i.recoil_id()) {
                A[cT](D)++;
                A[cT](V)++;
                A[cV](iid,i.cellid0())++;
            } else A[cT](H)++;
            A[isCollision](iid,cid) += i.ncoll();
            A[isFlightPath](iid,cid) += i.path();
            A[eIoniz](iid,cid) += i.ioniz();
            A[ePhonon](iid,cid) += i.erg() + i.phonon();
            break;
        case Event::IonStop:
            A[cT](I)++;
            A[cI](iid,cid)++;
            if (i.recoil_id()) {
                A[cT](D)++;
                A[cT](V)++;
                A[cV](iid,i.cellid0())++;
            }  else A[cT](H)++;
            A[isCollision](iid,cid) += i.ncoll();
            A[isFlightPath](iid,cid) += i.path();
            A[eIoniz](iid,cid) += i.ioniz();
            A[ePhonon](iid,cid) += i.erg() + i.phonon();
            break;
        case Event::IonExit:
            A[cT](L)++;
            A[cL](iid,pid)++;
            if (i.recoil_id()) {
                A[cT](D)++;
                A[cT](V)++;
                A[cV](iid,i.cellid0())++;
            } else A[cT](H)++;
            A[isCollision](iid,pid) += i.ncoll();
            A[isFlightPath](iid,pid) += i.path();
            A[eIoniz](iid,pid) += i.ioniz();
            A[ePhonon](iid,pid) += i.phonon();
            A[eLost](iid,pid) += i.erg();
            break;
        case Event::CascadeComplete:
            A[cT](P) += 1;
            A[cP](iid,cid)++;
            p = reinterpret_cast<const float*>(pv);
            A[ePKA](iid,cid) += p[0];
            A[dpTdam_LSS](iid,cid) += p[1];
            A[dpVnrt_LSS](iid,cid) += p[2];
            A[dpTdam](iid,cid) += p[3];
            A[dpVnrt](iid,cid) += p[4];
            break;
        default:
            break;
        }

    }


};



#endif // TALLY_H
