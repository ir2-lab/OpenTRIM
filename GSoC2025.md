# GSoC 2025

## user_tally json structure

This is the structure

```[javascript]

{
    "UserTally": {
        "id": "My tally" // User defined tally id
        "event": "IonStop",
        "geometry": "xyz", // Cartesian
        "origin": [0,0,0]
    }
}

```

## multi-dimensional binning

1. Create an enum code system e.g. 
```[c++]
enum variable_code {cX, cY, cZ};
```


2. Create a vector of variable codes.
```[c++]
std::vector<variable_code> bin_codes;
```


3. Create a vector of bin vectors.
```[c++]
std::vector<std::vector<float>> bins;
```


4. Create a vector of bin sizes.
```[c++]
std::vector<size_t> bin_sizes;
```


5. In the user_tally::init()

## 16.7.2025 - Comments on commit [d28fa7f](https://github.com/ir2-lab/OpenTRIM/commit/d28fa7f07c824bc19bf16b985944dfa7eceef4a2)

### Multi-dim Binning algorithm

Looks OK for a 1st try.

Improvements/corrections needed:

- **Rejection of out-of-bins ions**
  If the ion coordinates are outside the bins then the ion should be rejected.
  E.g. if the ion has x=100 and the x_bins are x=[200 300 400] then there is no score for the ion
  Thus `std::upper_bound(par_.x.begin(), par_.x.end(), pos) - par_.x.begin() - 1` will return an invalid index value (either -1 or past the end of the bins).
  The algorithm should take into account that if the particle is out of the bins for some variable, then the ion does not score.
  The ion should be rejected right away when this is found, to save time. (not scan all binning variables first and then decide)
  
  
- **Index vector** 
  `std::vector<size_t> idx` (return value of `user_tally::get_bin`)
  This should be made a member variable of class user_tally.
  Will be allocated once in the `user_tally::init()`.
  Otherwise a new idx is allocated for each particle

- **multiple for loops**
  In user_tally::get_bin there are 3 for loops. I think this is not optimal. In the final algorithm there should be 1 loop.

Suggested modification:

- Add `std::vector<size_t> idx` as member in `user_tally`
  This is a placeholder for the multi-d index.
  Allocate in `init()`
- Change `get_bin` function definition to 
  `bool get_bin(const ion& i)`
  where the return value is
  `true` = the particle was inside the bins, idx is valid
  `false` = the particle was outside the bins, idx is invalid


Inside `get_bin` use a single `for` loop over the bins.
- First calculate the value to be binned. 
- Then find the bin index.

This can be accomplished for example by the following code:
```c++
for (int j=0;j<n;++j) 
{
    float v; // value for the given bin variable
    switch (bin_codes[j]) {
    case cX:
        v = i.pos()[0];
        break;
    ...
    ...
    case cR:
        v = sqrt(pow(i.pos()[0],2)+pow(i.pos()[1],2)+pow(i.pos()[2],2)); // ion_r = sqrt(x^2+y^2+z^2)
        break;
    ...
    ...
    }
    // get bin index for v
    idx[j] = std::upper_bound(bins[j].begin(), bins[j].end(), v) - bins[j].begin() - 1; 
    // check bin index
    if (idx[j] < 0 || idx[j] >= bin_sizes[j]) return false; // invalid index -> reject
}
```
Then, inside `operator()` you can simply do
```c++
    if (get_bin(i)) data_(idx)++;
```

### Coordinate conversions  
  
The following code           
  ```
  case cPhi:
    pos = atan(i.pos()[1]/i.pos()[0]); // ion_phi = atan(y/x)
  ```
is dangerous.    
If ions' x is zero or both x & y are zero the result is undefined. 
Use `std::atan2(y,x)` instead.
Similar for `cTheta`.
  
In general, change of coordinates should be optimized. 

  The final goal is the following:
  - User defines the tally coord. system (CS1) by giving 
    - `origin`, 3D vector, origin of new CS1, $R$
    - `axis` - 3D vector, unit vector parallel to z-axis of CS1, $n_z$
  - Find the transformation matrix $M(n_z)$ so that $r' = M \dot (r-R)$, where $r, r'$ are the ion position vectors in CS0 and CS1, resp.
  - Convert $r'$ to cyl or sph if needed 

  Please try to work out the math and we can find a way to better code it using c++ libraries (Eigen probably)

Other optimizations for the coordinate binning could be:
- in binning over $r$ we can convert bin variable to $r^2$. This avoids using `sqrt`. Bin counts are not affected
- similarly, for binning over angles, we can devise some clever transform so that we do not need `atan` etc.

### Other suggestions
  
- `coordinates` should be an enum type - not string (to optimize comparisons, better clarity, etc)
  For that, the following is needed:
  1. Define a public enum inside `class user_tally`, e.g.
     `enum coordinate_t { xyz, cyl, sph };`
  2. In `parameters` add a member of this type: `coordinate_t coorinates`
     Default value should be `xyz`
  3. Add the enum definition in `parse_json.cpp` (so that it can be translated from json). see other enums for examples
  4. in `parse_json.cpp`, update the definition for `user_tally::parameters`
     Now the user input from json is translated correctly
  5. In c++ you can write 
     `switch ( coordinates ) { ... }`
     instead of `if (coordinates == "xyz")` which is slow


## 20.8.2025 - Comments on commits [5ab5bea](https://github.com/ir2-lab/OpenTRIM/commit/5ab5beaa0aac62fdef046359a21d459b27d8395e) & [3c6c1a9](https://github.com/ir2-lab/OpenTRIM/commit/3c6c1a9ddc64532d749890a39017ad21ff8dcea3)

The main goals for this period, i.e., to insert the ion velocity and the atom_id as user tally variables, has been succesfully achieved.

I made a few changes and pushed them to the gsoc branch. The changes do the following:

- introduce a new function user_tally::push_bins to reduce code repetition while initializing the user_tally object
- correct a detail in the bin structure: when the user specifies $N$ bin edges for a tally variable, say $(x_0, x_1, ... x_{N-1})$, then the number of bins is $N-1$. This is incorporated in the new function user_tally::push_bins. This feature has to be checked/debugged.

Also, one of OpenTRIM's dependencies was updated (isotope_data) and a change was needed in file `genptable.cpp` so that the project can be compiled.





















