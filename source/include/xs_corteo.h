#ifndef CORTEO_XS_H
#define CORTEO_XS_H

#include "xs.h"
#include "corteo.h"

#include <Eigen/Dense>

/**
 * \defgroup xs_corteo Corteo-style tabulated cross-sections
 *
 * \brief Screened Coulomb scattering tables utilizing corteo indexing.
 *
 * For fast calculation of ion scattering in Monte-Carlo simulations, we need tabulated
 * scattering integrals.
 *
 * Here, we use the Corteo indexing scheme to define a 2-dimensional grid of reduced energy
 * and impact parameter values \f$ (\epsilon_i, s_j ) \f$.
 *
 * Both \f$ \epsilon_i \f$ and \f$ s_j  \f$ are log-spaced Corteo index ranges. They are
 * defined in the class \ref xs_corteo_index.
 *
 * The class \ref corteo_xs_lab inherits the \ref xs_lab cross-section object and can be used
 * for scattering calculations of a specific projectile/target combination. It stores internally
 * 2-dimensional scattering tables and uses interpolation to calculate the scattering for
 * given energy and impact parameter.
 *
 *
 * @ingroup XS
 *
 *
 */

/**
 * @brief The xs_corteo_index struct provides corteo indexing for tabulated screened Coulomb
 * cross-sections
 *
 * Quantities are tabulated as a function of reduced energy and impact parameter
 *
 * This structure defines two 4-bit corteo indexes:
 *   - e_index for the reduced energy with [21-(-19)]*2^4 + 1=641 points (rows) from \f$ 2^{-19} \f$
 * to \f$ 2^{21} \f$
 *   - s_index for the reduced impact parameter with [6-(-26)]*2^4 + 1=513 points (columns) from \f$
 * 2^{-26} \f$ to \f$ 2^{6} \f$
 *
 * Required memory for the tabulated floating point data: 1.25 MB
 *
 * @ingroup xs_corteo
 */
struct xs_corteo_index
{
    /// Corteo 4-bit index for the reduced energy
    typedef corteo::index<float, int, 4, -19, 21> e_index;
    /// Corteo 4-bit index for the reduced impact parameter
    typedef corteo::index<float, int, 4, -26, 6> s_index;
    /// number of rows (energy values)
    constexpr static const int rows = e_index::size;
    /// number of columns (impact parameter values)
    constexpr static const int cols = s_index::size;
    /**
     * @brief Calculate the table index for given energy and impact parameter
     *
     * Return the index to the memory location where the value that corresponds
     * to given energy and impact parameter is stored.
     *
     * Tables are stored in C-style row-major order.
     *
     * @param e the reduced energy
     * @param s the reduced impact parameter
     * @return the table index
     */
    static int table_index(const float &e, const float &s)
    {
        return e_index(e) * cols + s_index(s);
    }
};

// pointers to raw scattering tables
// generated by gencorteo.cpp
const float *xs_zbl_data();
const float *xs_krc_data();
const float *xs_lj_data();
const float *xs_moliere_data();

/*
 * Access to corteo-tabulated screened Coulomb scattering integrals
 *
 * Depending on the ScreeningType template parameter
 * data() returns a pointer to the raw scattering table
 *
 * Tables are 2-dimensional and store values of sin^2(θ(ε,s)/2) on
 * a xs_corteo_index grid of (ε,s) points.
 *
 * A 2-dimensional pre-caclulated table of \f$ \sin^2\theta/2 \f$ as a function of reduced energy
 * and reduced impact parameter, where \f$ \theta \f$ is
 * the center-of-mass scattering angle.
 *
 * The type of screening is defined by the template parameter \ref ScreeningType
 * of enum type \ref Screening.
 *
 * The table is generated by \ref xs_quad, which
 * employs Gauss–Chebyshev quadrature to compute the scattering integral.
 *
 * The tabulated values are calculated at log-spaced energy
 * and impact factor values as documented in \ref xs_corteo_index.
 *
 * @tparam ScreeningType the type of screening
 *
 * @ingroup xs_corteo
 */
template <Screening ScreeningType>
struct xs_corteo4bit
{
    /// The 2D corteo index type
    typedef xs_corteo_index corteo_idx_t;
    /// Number of table rows (energy values)
    constexpr const static int rows = corteo_idx_t::rows;
    /// Number of table columns (impact parameter values)
    constexpr const static int cols = corteo_idx_t::cols;

    /// Returns the tabulated value of \f$ \sin^2\theta(\epsilon,s)/2 \f$
    static double sin2Thetaby2(const double &e, const double &s)
    {
        const float *p = data();
        int i = corteo_idx_t::table_index(e, s);
        return p[i];
    }
    /// Returns the tabulated value of \f$ \sin^2\theta(i,j)/2 \f$
    static float sin2Thetaby2(int ie, int is)
    {
        const float *p = data();
        return p[ie * cols + is];
    }
    /// Returns pointer to raw tabulated data
    static const float *data() { return nullptr; }
};
template <>
inline const float *xs_corteo4bit<Screening::ZBL>::data()
{
    return xs_zbl_data();
}
template <>
inline const float *xs_corteo4bit<Screening::LenzJensen>::data()
{
    return xs_lj_data();
}
template <>
inline const float *xs_corteo4bit<Screening::KrC>::data()
{
    return xs_krc_data();
}
template <>
inline const float *xs_corteo4bit<Screening::Moliere>::data()
{
    return xs_moliere_data();
}

// helper object for doing bilinear interpolation
// on the 2-d xs_corteo_index grid
struct xs_corteo_lin_interp
{

    constexpr const static int stride = xs_corteo_index::cols;
    typedef xs_corteo_index::e_index e_index;
    typedef xs_corteo_index::s_index s_index;
    typedef Eigen::Vector4i idx_vec_t;
    typedef Eigen::Vector4f coef_vec_t;

    /*
     * For interpolation values e and s get an array of indexes i
     * and an array of coefficients, c, so that
     *
     * F(e,s) = sum_i c_i * F_i
     *
     * gives the bilinear interpolation
     *
     */
    static void get_arrays(float e, float s, idx_vec_t &i, coef_vec_t &c)
    {
        e_index ie(e);
        s_index is(s);
        int k = ie * stride + is;
        i[0] = k++;
        i[1] = k;
        k += stride - 1;
        i[2] = k++;
        i[3] = k;
        float t = *ie++, u = *is++;
        t = (e - t) / (*ie - t);
        u = (s - u) / (*is - u);
        c = { (1 - t) * (1 - u), (1 - t) * u, t * (1 - u), t * u };
    }
};

// helper object for biliear & bi-log interpolation
// on 2-d tabulated data with xs_corteo_index
struct xs_corteo_log_interp
{

    constexpr const static int stride = xs_corteo_index::cols;
    typedef xs_corteo_index::e_index e_index;
    typedef xs_corteo_index::s_index s_index;
    typedef Eigen::Vector4i idx_vec_t;
    typedef Eigen::Vector4f coef_vec_t;

    xs_corteo_log_interp()
    {
        for (e_index i; i < i.end(); i++)
            log_e_[i] = std::log2(*i);
        for (s_index i; i < i.end(); i++)
            log_s_[i] = std::log2(*i);
    }

    void get_arrays(float e, float s, idx_vec_t &i, coef_vec_t &c_lin, coef_vec_t &c_log) const
    {
        e_index ie(e);
        s_index is(s);
        int k = ie * stride + is;
        i[0] = k++;
        i[1] = k;
        k += stride - 1;
        i[2] = k++;
        i[3] = k;

        float t = *ie, u = *is;
        float t1 = log_e_[ie++], u1 = log_s_[is++];
        t = (e - t) / (*ie - t);
        u = (s - u) / (*is - u);
        c_lin = { (1 - t) * (1 - u), (1 - t) * u, t * (1 - u), t * u };

        t1 = (std::log2(e) - t1) / (log_e_[ie] - t1);
        u1 = (std::log2(s) - u1) / (log_s_[is] - u1);
        c_log = { (1 - t1) * (1 - u1), (1 - t1) * u1, t1 * (1 - u1), t1 * u1 };
    }

    void get_arrays(float e, float s, idx_vec_t &i, coef_vec_t &c_log) const
    {
        e_index ie(e);
        s_index is(s);
        int k = ie * stride + is;
        i[0] = k++;
        i[1] = k;
        k += stride - 1;
        i[2] = k++;
        i[3] = k;

        float t1 = log_e_[ie++], u1 = log_s_[is++];
        t1 = (std::log2(e) - t1) / (log_e_[ie] - t1);
        u1 = (std::log2(s) - u1) / (log_s_[is] - u1);
        c_log = { (1 - t1) * (1 - u1), (1 - t1) * u1, t1 * (1 - u1), t1 * u1 };
    }

private:
    Eigen::Matrix<float, e_index::size, 1> log_e_;
    Eigen::Matrix<float, s_index::size, 1> log_s_;
};

/**
 * @brief A lab system cross-section class utilizing corteo tabulated scattering integrals
 *
 * The class stores internally 2-dimensional tables of
 * - \f$ \sin^2(\theta/2), \f$
 * - \f$ \sin( \Theta ), \f$ and
 * - \f$ \cos( \Theta ), \f$
 *
 * where \f$\theta \f$ and \f$\Theta \f$ are scattering angles in center-of-mass
 * and lab systems, on a log-spaced reduced energy and impact
 * parameter grid.
 *
 * Bilinear interpolation is used to obtain the values of these quantities
 * for the scattering of a projectile of energy \f$ E\f$ and impact parameter \f$P\f$.
 *
 * First, the reduced energy and impact parameter \f$(\epsilon, s)\f$ are found and the
 * interpolation ranges are search to find the index \f$(i,j)\f$ such that
 * \f[
 * \begin{align*}
 * \epsilon_i & \leq \epsilon < \epsilon_{i+1} \\
 * s_j & \leq s < s_{j+1}
 * \end{align*}
 * \f]
 *
 * Then, define
 * \f[
 * \begin{align*}
 * t &= (\log\epsilon - \log\epsilon_i)/(\log\epsilon_{i+1} - \log\epsilon_i) \\
 * u &= (\log s - \log s_j)/(\log s_{j+1} - \log s_j)
 * \end{align*}
 * \f]
 *
 * For a tabulated function \f$y_{i,j} = y(\epsilon_i, s_j)\f$ the bilinear interpolation
 * reads:
 * \f[
 * y(\epsilon, s) \approx y_{i,j} (1 - t)(1 - u) +
 * y_{i,j+1} (1 - t)u + y_{i+1,j} t(1 - u) + y_{i+1,j+1} tu
 * \f]
 *
 * For \f$ y = \sin^2(\theta_{CM}/2) \f$ log-log interpolation is used, while for the
 * sine and cosine of lab scattering angle the interpolation is log-lin.
 *
 * Finally, the energy transfer is obtained by \f$T=\gamma E \sin^2(\theta/2)\f$
 * and the sine and cosine of the lab scattering angle are obtained directly from
 * the interpolation.
 *
 * @tparam ScreeningType the type of screening
 *
 * @ingroup xs_corteo
 */
template <Screening ScreeningType>
class corteo_xs_lab : public xs_lab<ScreeningType>
{
    typedef xs_cms<ScreeningType> _xs_cms_t;
    typedef xs_lab<ScreeningType> _xs_lab_t;
    typedef xs_corteo4bit<ScreeningType> _xs_corteo_t;
    typedef typename _xs_corteo_t::corteo_idx_t corteo_idx_t;
    typedef typename corteo_idx_t::e_index e_index;
    typedef typename corteo_idx_t::s_index s_index;
    constexpr const static int stride = corteo_idx_t::cols;
    constexpr const static int array_size = corteo_idx_t::rows * corteo_idx_t::cols;

    // explicitly shared arrays
    typedef Eigen::VectorXf xs_array_t;
    xs_array_t sinTable, cosTable;
    xs_array_t log_s2;
    xs_corteo_log_interp interp;

    using abstract_xs_lab::gamma_;
    using abstract_xs_lab::mass_ratio_;
    using abstract_xs_lab::red_E_conv_;
    using abstract_xs_lab::screening_length_;

public:
    corteo_xs_lab(int Z1, float M1, int Z2, float M2)
        : _xs_lab_t(Z1, M1, Z2, M2), sinTable(array_size), cosTable(array_size), log_s2(array_size)
    {
        /* compute scattering angle components */
        double costhetaLab, sinthetaLab;
        double mr = mass_ratio_;
        for (e_index ie; ie != ie.end(); ie++)
            for (s_index is; is != is.end(); is++) {
                double s2 = _xs_corteo_t::sin2Thetaby2(ie, is);
                double costheta = 1. - 2. * s2;

                if (costheta == -1.0 && mr == 1.0) {
                    costhetaLab = 0.0; /* peculiar case of head-on collision of identical masses */
                    sinthetaLab = 1.0;
                } else {
                    costhetaLab = (costheta + mr) / sqrt(1. + 2. * mr * costheta + mr * mr);
                    sinthetaLab = sqrt(1. - costhetaLab * costhetaLab);
                }

                int k = ie * stride + is;
                cosTable[k] = costhetaLab;
                sinTable[k] = sinthetaLab;
                log_s2[k] = std::log2(s2);

                /* IRADINA, C. Borschel 2011: */
                /* In some rare cases, when cos=1, then sin becomes "Not a Number".
                 * To prevent this, I will set the sine to 0 in those cases. */
                if (std::isnan(sinTable[k])) {
                    cosTable[k] = 0.f;
                    sinTable[k] = 1.f;
                }
            }
    }
    corteo_xs_lab(const corteo_xs_lab &x)
        : _xs_lab_t(x), sinTable(x.sinTable), cosTable(x.cosTable), log_s2(x.log_xs_)
    {
    }

    virtual void scatter(float e, float s, float &recoil_erg, float &sintheta,
                         float &costheta) const override
    {
        const float *p = _xs_corteo_t::data();
        recoil_erg = e * gamma_;
        e *= red_E_conv_;
        s /= screening_length_;

        Eigen::Vector4i i;
        Eigen::Vector4f coeff, log_coeff;

        // get coeffs for bilin & bilog interpolation
        interp.get_arrays(e, s, i, coeff, log_coeff);

        // bilinear interpolation for sin & cos
        sintheta = coeff.dot(sinTable(i));
        costheta = coeff.dot(cosTable(i));

        // bilog interpolation for sin^2(θ/2)
        recoil_erg *= exp2(log_coeff.dot(log_s2(i)));
    }
};

/*
 * @brief xs_lab implementation with ZBL potential and 4-bit corteo tabulated scattering integrals
 *
 * @ingroup xs_corteo
 */
typedef corteo_xs_lab<Screening::ZBL> xs_lab_zbl;
/*
 * @brief xs_lab implementation with Lenz-Jensen potential and 4-bit corteo tabulated scattering
 * integrals
 *
 * @ingroup xs_corteo
 */
typedef corteo_xs_lab<Screening::LenzJensen> xs_lab_lj;
/*
 * @brief xs_lab implementation with Kr-C potential and 4-bit corteo tabulated scattering integrals
 *
 * @ingroup xs_corteo
 */
typedef corteo_xs_lab<Screening::KrC> xs_lab_krc;
/*
 * @brief xs_lab implementation with Moliere potential and 4-bit corteo tabulated scattering
 * integrals
 *
 * @ingroup xs_corteo
 */
typedef corteo_xs_lab<Screening::Moliere> xs_lab_moliere;

#endif // CORTEO_XS_H
