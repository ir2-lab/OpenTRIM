#include "scattering.h"

#include <iostream>
#include <fstream>
#include <algorithm>
#include <charconv>

#include <CLI/CLI.hpp>

using std::cerr;
using std::cout;
using std::endl;
using std::ofstream;

template <Screening ScreeningType>
int gen_scattering_tbl(const std::string &short_screening_name);

int main(int argc, char *argv[])
{

    CLI::App app{ "Generate screened Coulomb scattering table", "gen_scattering_tbl" };

    Screening s(Screening::ZBL);
    std::string short_screening_name("zbl");

    app.add_option("-s,--screening", short_screening_name,
                   "Screening type: one of ZBL, Bohr, KrC, Moliere");

    CLI11_PARSE(app, argc, argv);

    std::transform(short_screening_name.begin(), short_screening_name.end(),
                   short_screening_name.begin(), [](unsigned char c) { return std::tolower(c); });

    if (short_screening_name == "zbl")
        s = Screening::ZBL;
    else if (short_screening_name == "krc")
        s = Screening::KrC;
    else if (short_screening_name == "bohr")
        s = Screening::Bohr;
    else if (short_screening_name == "moliere")
        s = Screening::Moliere;
    else {
        cerr << "Unknown screening type option: " << short_screening_name << endl;
        return -1;
    }

    switch (s) {
    case Screening::ZBL:
        return gen_scattering_tbl<Screening::ZBL>(short_screening_name);
        break;
    case Screening::KrC:
        return gen_scattering_tbl<Screening::KrC>(short_screening_name);
        break;
    case Screening::Bohr:
        return gen_scattering_tbl<Screening::Bohr>(short_screening_name);
        break;
    case Screening::Moliere:
        return gen_scattering_tbl<Screening::Moliere>(short_screening_name);
        break;
    default:
        return -1;
        break;
    }

    return 0;
}

const char *preample = "/*\n"
                       " * file generated by gen_scattering_tbl utility of OpenTRIM \n"
                       " * \n"
                       " * do not edit \n"
                       " */\n";

// print out a 32bit float so that it is read back the same
// employ C++17 std::to_chars to be system locale independent
std::ostream &printfloat(std::ostream &os, float x)
{
    if (!finite(x)) {
        os << "-1.0f/0.0f";
        return os;
    }

    // print buffer
    static constexpr int buff_len = 32;
    char buff[buff_len]{};
    // get number of digits for a float -> text -> float round-trip
    static constexpr auto d = std::numeric_limits<float>::max_digits10;
    // print the number
    std::to_chars_result ret =
            std::to_chars(buff, buff + buff_len, x, std::chars_format::general, d);
    *ret.ptr = 0;
    os << buff;
    return os;
}

template <Screening ScreeningType>
int gen_scattering_tbl(const std::string &short_screening_name)
{
    xs_cms<ScreeningType> xs;

    cout << "Computing " << xs.screeningName() << " scattering table";

    // create func name
    std::string func("xs_");
    func += short_screening_name;
    func += "_data";

    ofstream ofs(func + ".cpp");
    ofs << preample << endl;
    ofs << "static const float " << func << "_[] = {\n";

    // compute matrix for each reduced energy, reduced impact parameter pair
    int k = 0;
    int klast = scattering_tbl_grid::size - 1;
    for (scattering_tbl_grid::e_iterator_t ie; ie < ie.end(); ie++) {

        if (ie % (scattering_tbl_grid::rows / 10) == 0) {
            cout << ".";
            cout.flush();
        }

        for (scattering_tbl_grid::s_iterator_t is; is < is.end(); is++) {
            float mu = xs.sin2Thetaby2(*ie, *is);
            // double log2mu = std::log2(mu);
            // if (!finite(log2mu)) {
            //     cout << "infinit log2(mu)" << endl;
            //     cout << "Screening: " << xs.screeningName() << endl;
            //     cout << "e = " << *ie << endl;
            //     cout << "s = " << *is << endl;
            //     cout << "mu = " << mu << endl;
            //     cout << "log2(mu) = " << log2mu << endl;
            //     cout << "exp2(log2(mu)) = " << std::exp2(log2mu) << endl;
            //     // exit(-1);
            // }
            printfloat(ofs, mu);
            if (k != klast)
                ofs << ',';
            k++;
            if (k % 16 == 0)
                ofs << endl;
        }
    }

    ofs << "}; \n\n";

    ofs << "const float* " << func << "() { return " << func << "_; } \n";

    cout << " done.\n";
    cout.flush();

    return 0;
}
