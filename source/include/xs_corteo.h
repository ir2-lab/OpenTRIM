#ifndef CORTEO_XS_H
#define CORTEO_XS_H

#include <screened_coulomb.h>
#include "corteo.h"

#include <Eigen/Dense>

/**
 * \defgroup XS Nuclear scattering
 *
 * \brief Scattering of ions by target atoms described by the screened Coulomb interaction.
 *
 * The scattering is considered elastic and it is approximated by classical kinematics.
 *
 * For fast calculation of scattering in the Monte-Carlo simulation, we employ interpolation
 * on 2-d tables of scattering quantities.
 *
 * The Corteo indexing scheme is used to define a 2-dimensional grid of reduced
 * center-of-mass energy and impact parameter values \f$ (\epsilon_i, s_j ) \f$.
 *
 * Both \f$ \epsilon_i \f$ and \f$ s_j  \f$ are log-spaced Corteo index ranges. They are
 * defined in the class \ref xs_corteo_index.
 *
 * The class \ref corteo_xs_lab can be used
 * for scattering calculations on a specific projectile/target combination. It stores internally
 * 2-dimensional scattering tables and uses interpolation to calculate the scattering for
 * given energy and impact parameter.
 *
 */

/**
 * @brief The xs_corteo_index struct provides corteo indexing for tabulated screened Coulomb
 * cross-sections
 *
 * Quantities are tabulated as a function of reduced energy and impact parameter
 *
 * This structure defines two 4-bit corteo indexes:
 *   - e_index for the reduced energy with [21-(-19)]*2^4 + 1=641 points (rows) from \f$ 2^{-19} \f$
 * to \f$ 2^{21} \f$
 *   - s_index for the reduced impact parameter with [6-(-26)]*2^4 + 1=513 points (columns) from \f$
 * 2^{-26} \f$ to \f$ 2^{6} \f$
 *
 * Required memory for the tabulated floating point data: 1.25 MB
 *
 * @ingroup XS
 */
struct xs_corteo_index
{
    /// Corteo 4-bit index for the reduced energy
    typedef corteo::index<float, int, 4, -19, 21> e_index;
    /// Corteo 4-bit index for the reduced impact parameter
    typedef corteo::index<float, int, 4, -26, 6> s_index;
    /// number of rows (energy values)
    constexpr static const int rows = e_index::size;
    /// number of columns (impact parameter values)
    constexpr static const int cols = s_index::size;
    /**
     * @brief Calculate the table index for given energy and impact parameter
     *
     * Return the index to the memory location where the value that corresponds
     * to given energy and impact parameter is stored.
     *
     * Tables are stored in C-style row-major order.
     *
     * @param e the reduced energy
     * @param s the reduced impact parameter
     * @return the table index
     */
    static int table_index(const float &e, const float &s)
    {
        return e_index(e) * cols + s_index(s);
    }
};

// pointers to raw scattering tables
// generated by gencorteo.cpp
const float *xs_zbl_data();
const float *xs_krc_data();
const float *xs_bohr_data();
const float *xs_moliere_data();

/*
 * Access to corteo-tabulated screened Coulomb scattering integrals
 *
 * Depending on the ScreeningType template parameter
 * data() returns a pointer to the raw scattering table
 *
 * Tables are 2-dimensional and store values of sin^2(θ(ε,s)/2) on
 * a xs_corteo_index grid of (ε,s) points.
 *
 * A 2-dimensional pre-caclulated table of \f$ \sin^2\theta/2 \f$ as a function of reduced energy
 * and reduced impact parameter, where \f$ \theta \f$ is
 * the center-of-mass scattering angle.
 *
 * The type of screening is defined by the template parameter \ref ScreeningType
 * of enum type \ref Screening.
 *
 * The table is generated by \ref xs_quad, which
 * employs Gauss–Chebyshev quadrature to compute the scattering integral.
 *
 * The tabulated values are calculated at log-spaced energy
 * and impact factor values as documented in \ref xs_corteo_index.
 *
 * @tparam ScreeningType the type of screening
 *
 * @ingroup XS
 */
template <Screening ScreeningType>
struct xs_corteo4bit
{
    /// The 2D corteo index type
    typedef xs_corteo_index corteo_idx_t;
    /// Number of table rows (energy values)
    constexpr const static int rows = corteo_idx_t::rows;
    /// Number of table columns (impact parameter values)
    constexpr const static int cols = corteo_idx_t::cols;

    /// Returns the tabulated value of \f$ \sin^2\theta(\epsilon,s)/2 \f$
    static double sin2Thetaby2(const double &e, const double &s)
    {
        const float *p = data();
        int i = corteo_idx_t::table_index(e, s);
        return p[i];
    }
    /// Returns the tabulated value of \f$ \sin^2\theta(i,j)/2 \f$
    static float sin2Thetaby2(int ie, int is)
    {
        const float *p = data();
        return p[ie * cols + is];
    }
    /// Returns pointer to raw tabulated data
    static const float *data() { return nullptr; }
};
template <>
inline const float *xs_corteo4bit<Screening::ZBL>::data()
{
    return xs_zbl_data();
}
template <>
inline const float *xs_corteo4bit<Screening::Bohr>::data()
{
    return xs_bohr_data();
}
template <>
inline const float *xs_corteo4bit<Screening::KrC>::data()
{
    return xs_krc_data();
}
template <>
inline const float *xs_corteo4bit<Screening::Moliere>::data()
{
    return xs_moliere_data();
}

// helper object for doing bilinear interpolation
// on the 2-d xs_corteo_index grid
struct xs_corteo_lin_interp
{

    constexpr const static int stride = xs_corteo_index::cols;
    typedef xs_corteo_index::e_index e_index;
    typedef xs_corteo_index::s_index s_index;
    typedef Eigen::Vector4i idx_vec_t;
    typedef Eigen::Vector4f coef_vec_t;

    /*
     * For interpolation values e and s get an array of indexes i
     * and an array of coefficients, c, so that
     *
     * F(e,s) = sum_i c_i * F_i
     *
     * gives the bilinear interpolation
     *
     */
    static void get_arrays(float e, float s, idx_vec_t &i, coef_vec_t &c)
    {
        e_index ie0(e), ie1(ie0);
        s_index is0(s), is1(is0);
        if (e >= e_index::maxVal)
            ie0--;
        else
            ie1++;
        if (s >= s_index::maxVal)
            is0--;
        else
            is1++;

        int k = ie0 * stride + is0;
        i[0] = k++;
        i[1] = k;
        k += stride - 1;
        i[2] = k++;
        i[3] = k;

        float t = *ie0, u = *is0;
        t = (e - t) / (*ie1 - t);
        u = (s - u) / (*is1 - u);
        c = { (1 - t) * (1 - u), (1 - t) * u, t * (1 - u), t * u };
    }
};

// helper object for biliear & bi-log interpolation
// on 2-d tabulated data with xs_corteo_index
struct xs_corteo_log_interp
{

    constexpr const static int stride = xs_corteo_index::cols;
    typedef xs_corteo_index::e_index e_index;
    typedef xs_corteo_index::s_index s_index;
    typedef Eigen::Vector4i idx_vec_t;
    typedef Eigen::Vector4f coef_vec_t;

    xs_corteo_log_interp()
    {
        for (e_index i; i < i.end(); i++)
            log_e_[i] = std::log2(*i);
        for (s_index i; i < i.end(); i++)
            log_s_[i] = std::log2(*i);
    }

    void get_arrays(float e, float s, idx_vec_t &i, coef_vec_t &c_lin, coef_vec_t &c_log) const
    {
        e_index ie0(e), ie1(ie0);
        s_index is0(s), is1(is0);
        if (e >= e_index::maxVal)
            ie0--;
        else
            ie1++;
        if (s >= s_index::maxVal)
            is0--;
        else
            is1++;

        int k = ie0 * stride + is0;
        i[0] = k++;
        i[1] = k;
        k += stride - 1;
        i[2] = k++;
        i[3] = k;

        float t = *ie0, u = *is0;
        float t1 = log_e_[ie0], u1 = log_s_[is0];
        t = (e - t) / (*ie1 - t);
        u = (s - u) / (*is1 - u);
        c_lin = { (1 - t) * (1 - u), (1 - t) * u, t * (1 - u), t * u };

        t1 = (std::log2(e) - t1) / (log_e_[ie1] - t1);
        u1 = (std::log2(s) - u1) / (log_s_[is1] - u1);
        c_log = { (1 - t1) * (1 - u1), (1 - t1) * u1, t1 * (1 - u1), t1 * u1 };
    }

    void get_arrays(float e, float s, idx_vec_t &i, coef_vec_t &c_log) const
    {
        e_index ie0(e), ie1(ie0);
        s_index is0(s), is1(is0);
        if (e >= e_index::maxVal)
            ie0--;
        else
            ie1++;
        if (s >= s_index::maxVal)
            is0--;
        else
            is1++;

        int k = ie0 * stride + is0;
        i[0] = k++;
        i[1] = k;
        k += stride - 1;
        i[2] = k++;
        i[3] = k;

        float t1 = log_e_[ie0], u1 = log_s_[is0];
        t1 = (std::log2(e) - t1) / (log_e_[ie1] - t1);
        u1 = (std::log2(s) - u1) / (log_s_[is1] - u1);
        c_log = { (1 - t1) * (1 - u1), (1 - t1) * u1, t1 * (1 - u1), t1 * u1 };
    }

private:
    Eigen::Matrix<float, e_index::size, 1> log_e_;
    Eigen::Matrix<float, s_index::size, 1> log_s_;
};

/**
 * @brief The abstract_xs_lab class defines the interface for lab system cross-section objects
 *
 * @ingroup XS
 */
class abstract_xs_lab
{
public:
    abstract_xs_lab() { }
    virtual ~abstract_xs_lab() { }
    virtual void scatter(float E, float P, float &recoil_erg, float &sintheta,
                         float &costheta) const = 0;
    virtual void scatter2(float E, float P, float &recoil_erg, float &sintheta,
                          float &costheta) const = 0;
    virtual float sin2Thetaby2(float e, float s) const = 0;
    virtual float find_p(float E, float T) const = 0;
    virtual float screening_length() const = 0;
    virtual float mass_ratio() const = 0;
    virtual float sqrt_mass_ratio() const = 0;
    virtual float gamma() const = 0;
    virtual float red_E_conv() const = 0;
    virtual const char *screeningName() const = 0;
};

/**
 * @brief A lab system cross-section class utilizing corteo tabulated scattering integrals
 *
 * The class stores internally 2-dimensional tables of
 * - \f$ \sin^2(\theta/2), \f$
 * - \f$ \sin( \Theta ), \f$
 *
 * where \f$\theta \f$ and \f$\Theta \f$ are scattering angles in center-of-mass
 * and lab systems, on a log-spaced reduced energy and impact
 * parameter grid.
 *
 * Bilinear interpolation is used to obtain the values of these quantities
 * for the scattering of a projectile of energy \f$ E\f$ and impact parameter \f$P\f$.
 *
 * First, the reduced energy and impact parameter \f$(\epsilon, s)\f$ are found and the
 * interpolation ranges are search to find the index \f$(i,j)\f$ such that
 * \f[
 * \begin{align*}
 * \epsilon_i & \leq \epsilon < \epsilon_{i+1} \\
 * s_j & \leq s < s_{j+1}
 * \end{align*}
 * \f]
 *
 * Then, define
 * \f[
 * \begin{align*}
 * t &= (\log\epsilon - \log\epsilon_i)/(\log\epsilon_{i+1} - \log\epsilon_i) \\
 * u &= (\log s - \log s_j)/(\log s_{j+1} - \log s_j)
 * \end{align*}
 * \f]
 *
 * For a tabulated function \f$y_{i,j} = y(\epsilon_i, s_j)\f$ the bilinear interpolation
 * reads:
 * \f[
 * y(\epsilon, s) \approx y_{i,j} (1 - t)(1 - u) +
 * y_{i,j+1} (1 - t)u + y_{i+1,j} t(1 - u) + y_{i+1,j+1} tu
 * \f]
 *
 * For \f$ y = \sin^2(\theta_{CM}/2) \f$ log-log interpolation is used, while for the
 * sine and cosine of lab scattering angle the interpolation is log-lin.
 *
 * Finally, the energy transfer is obtained by \f$T=\gamma E \sin^2(\theta/2)\f$
 * and the sine and cosine of the lab scattering angle are obtained directly from
 * the interpolation.
 *
 * @tparam ScreeningType the type of screening
 *
 * @ingroup XS
 */
template <Screening ScreeningType>
class corteo_xs_lab : public abstract_xs_lab, private xs_lab<ScreeningType>
{
public:
    typedef xs_cms<ScreeningType> _xs_cms_t;
    typedef xs_lab<ScreeningType> _xs_lab_t;
    typedef xs_corteo4bit<ScreeningType> _xs_corteo_t;
    typedef typename _xs_corteo_t::corteo_idx_t corteo_idx_t;
    typedef typename corteo_idx_t::e_index e_index;
    typedef typename corteo_idx_t::s_index s_index;
    constexpr const static int stride = corteo_idx_t::cols;
    constexpr const static int array_size = corteo_idx_t::rows * corteo_idx_t::cols;

    // explicitly shared arrays
    typedef Eigen::VectorXf xs_array_t;
    xs_array_t sinTable;
    xs_array_t log_s2;
    xs_corteo_log_interp interp;

    corteo_xs_lab(int Z1, float M1, int Z2, float M2)
        : _xs_lab_t(Z1, M1, Z2, M2), sinTable(array_size), log_s2(array_size)
    {
        /* compute scattering angle components */
        double mr = mass_ratio();
        for (e_index ie; ie != ie.end(); ie++)
            for (s_index is; is != is.end(); is++) {
                double s2 = _xs_corteo_t::sin2Thetaby2(ie, is);

                /* convert CM scattering angle to lab frame of reference: */
                double costhetaCM = 1.0 - 2.0 * s2;
                double sinthetaCM = std::sqrt(1.0 - costhetaCM * costhetaCM);
                double thetaLab = std::atan2(sinthetaCM, (costhetaCM + mr));
                double costhetaLab = std::cos(thetaLab);
                double sinthetaLab = std::sin(thetaLab);

                // fill the tables
                int k = ie * stride + is;
                sinTable[k] = sinthetaLab;
                log_s2[k] = std::log2(s2);
            }
    }
    corteo_xs_lab(const corteo_xs_lab &x)
        : _xs_lab_t(x), sinTable(x.sinTable), log_s2(x.log_xs_) { }

    virtual void scatter2(float e, float s, float &recoil_erg, float &sintheta,
                          float &costheta) const override
    {
        const float *p = _xs_corteo_t::data();
        recoil_erg = e * gamma();
        e *= red_E_conv();
        s /= screening_length();

        Eigen::Vector4i i;
        Eigen::Vector4f log_coeff;

        // get coeffs for bilin & bilog interpolation
        interp.get_arrays(e, s, i, log_coeff);

        // bilog interpolation for sin^2(θ/2)
        float s2 = std::exp2(log_coeff.dot(log_s2(i)));
        recoil_erg *= s2;

        /* convert CM scattering angle to lab frame of reference: */
        costheta = 1.0f - 2.0f * s2;
        sintheta = std::sqrt(1.0f - costheta * costheta);
        float th = std::atan2(sintheta, (costheta + mass_ratio()));
        costheta = std::cos(th);
        sintheta = std::sin(th);
    }

    virtual void scatter(float e, float s, float &recoil_erg, float &sintheta,
                         float &costheta) const override
    {
        const float *p = _xs_corteo_t::data();
        recoil_erg = e * gamma();
        e *= red_E_conv();
        s /= screening_length();

        Eigen::Vector4i i;
        Eigen::Vector4f coeff, log_coeff;

        // get coeffs for bilin & bilog interpolation
        interp.get_arrays(e, s, i, coeff, log_coeff);

        // bilinear interpolation for lab sinTh
        sintheta = coeff.dot(sinTable(i));
        costheta = std::sqrt(1.f - sintheta * sintheta);

        // bilog interpolation for sin^2(θ/2)
        recoil_erg *= std::exp2(log_coeff.dot(log_s2(i)));
    }

    virtual float sin2Thetaby2(float e, float s) const override
    {
        Eigen::Vector4i i;
        Eigen::Vector4f log_coeff;

        // get coeffs for bilin & bilog interpolation
        interp.get_arrays(e, s, i, log_coeff);

        // bilog interpolation for sin^2(θ/2)
        return std::exp2(log_coeff.dot(log_s2(i)));
    }

    virtual float find_p(float E, float T) const { return _xs_lab_t::find_p(E, T); }
    virtual float screening_length() const { return _xs_lab_t::screening_length(); }
    virtual float mass_ratio() const { return _xs_lab_t::mass_ratio(); }
    virtual float sqrt_mass_ratio() const { return _xs_lab_t::sqrt_mass_ratio(); }
    virtual float gamma() const { return _xs_lab_t::gamma(); }
    virtual float red_E_conv() const { return _xs_lab_t::red_E_conv(); }
    virtual const char *screeningName() const { return _xs_lab_t::screeningName(); }
};

/*
 * @brief xs_lab implementation with ZBL potential and 4-bit corteo tabulated scattering integrals
 *
 * @ingroup XS
 */
typedef corteo_xs_lab<Screening::ZBL> xs_lab_zbl;
/*
 * @brief xs_lab implementation with Bohr potential and 4-bit corteo tabulated scattering
 * integrals
 *
 * @ingroup XS
 */
typedef corteo_xs_lab<Screening::Bohr> xs_lab_bohr;
/*
 * @brief xs_lab implementation with Kr-C potential and 4-bit corteo tabulated scattering integrals
 *
 * @ingroup XS
 */
typedef corteo_xs_lab<Screening::KrC> xs_lab_krc;
/*
 * @brief xs_lab implementation with Moliere potential and 4-bit corteo tabulated scattering
 * integrals
 *
 * @ingroup XS
 */
typedef corteo_xs_lab<Screening::Moliere> xs_lab_moliere;

#endif // CORTEO_XS_H
